// Dx9GPUPatch.cpp
#include <d3d9.h>
#include "Dx9GPUPatch.h"

HMODULE                 hD3D9Dll = NULL;

int                     patchType = 0;

extern bool             bDXGIHooked;


bool CompareMemory(const LPVOID lpVal1, const LPVOID lpVal2, UINT nBytes)
{
	__try
	{
		return memcmp(lpVal1, lpVal2, nBytes) == 0;
	}
	__except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
	{
		return false;
	}

	return false;
}

struct PatchInfo {
	size_t patchSize;
	const BYTE *patchData;
};

#define NewPatch(x) {sizeof(x), (x)}

#ifdef _WIN64

#define NUM_KNOWN_PATCHES 16
#define PATCH_COMPARE_SIZE 13
UPARAM patch_offsets[NUM_KNOWN_PATCHES] = {/*0x4B55F,*/ 0x54FE6, 0x55095, 0x550C5, 0x6E2FC, 0x6FE18, 0x70050, 0x703F8, 0x7E48C, 0x7E49C, 0x8BDB5, 0x8E635, 0x90352, 0x9038A, 0x93AFA, 0x93B8A, 0x1841E5 };
BYTE patch_compare[NUM_KNOWN_PATCHES][PATCH_COMPARE_SIZE] =
{
	//{0x48, 0x8b, 0x81, 0xc8, 0x38, 0x00, 0x00, 0x39, 0x98, 0x68, 0x50, 0x00, 0x00},  //winvis - 6.0.6002.18005
	{ 0x48, 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x39, 0x98, 0x68, 0x50, 0x00, 0x00 },  //win7   - 6.1.7600.16385
	{ 0x48, 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x39, 0x98, 0x68, 0x50, 0x00, 0x00 },  //win7   - 6.1.7601.16562
	{ 0x48, 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x39, 0x98, 0x68, 0x50, 0x00, 0x00 },  //win7   - 6.1.7601.17514
	{ 0x8b, 0x81, 0x18, 0x3e, 0x00, 0x00, 0x44, 0x39, 0x98, 0x90, 0x51, 0x00, 0x00 },  //win10  - 10.0.14393.0
	{ 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x44, 0x39, 0x98, 0x88, 0x51, 0x00, 0x00 },  //win10  - 10.0.10240.16412
	{ 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x44, 0x39, 0x98, 0x88, 0x51, 0x00, 0x00 },  //win10  - 10.0.10240.16384
	{ 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x44, 0x39, 0x98, 0x88, 0x51, 0x00, 0x00 },  //win10  - 10.0.10162.0
	{ 0x8b, 0x81, 0x18, 0x3e, 0x00, 0x00, 0x44, 0x39, 0x98, 0x88, 0x51, 0x00, 0x00 },  //win10  - 10.0.10586.494
	{ 0x8b, 0x81, 0x18, 0x3e, 0x00, 0x00, 0x44, 0x39, 0x98, 0x88, 0x51, 0x00, 0x00 },  //win10  - 10.0.10586.0
	{ 0x48, 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x39, 0xB0, 0x28, 0x51, 0x00, 0x00 },  //win8.1 - 6.3.9431.00000
	{ 0x48, 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x39, 0xA8, 0x28, 0x51, 0x00, 0x00 },  //win8.1 - 6.3.9600.17415
	{ 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x44, 0x39, 0xA0, 0x28, 0x51, 0x00, 0x00 },  //win8.1 - 6.3.9600.17085
	{ 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x44, 0x39, 0xA0, 0x28, 0x51, 0x00, 0x00 },  //win8.1 - 6.3.9600.17095
	{ 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x44, 0x39, 0xA0, 0x28, 0x51, 0x00, 0x00 },  //win8.1 - 6.3.9600.16384
	{ 0x8b, 0x81, 0xb8, 0x3d, 0x00, 0x00, 0x44, 0x39, 0xA0, 0x28, 0x51, 0x00, 0x00 },  //win8.1 - 6.3.9600.16404
	{ 0x49, 0x8b, 0x85, 0xb8, 0x3d, 0x00, 0x00, 0x39, 0x88, 0xc8, 0x50, 0x00, 0x00 },  //win8   - 6.2.9200.16384
};

static const BYTE forceJump[] = { 0xEB };
static const BYTE ignoreJump[] = { 0x90, 0x90 };

PatchInfo patch[NUM_KNOWN_PATCHES] =
{
	//{0xEB, 0x12},
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
};

#else

#define NUM_KNOWN_PATCHES 16
#define PATCH_COMPARE_SIZE 12
UPARAM patch_offsets[NUM_KNOWN_PATCHES] = {/*0x4BDA1,*/ 0x79AA6, 0x79C9E, 0x79D96, 0x7F9BD, 0x8A3F4, 0x8B15F, 0x8B19F, 0x8B83F, 0x8E9F7, 0x8F00F, 0x8FBB1, 0x90264, 0x90C57, 0x90C3A, 0x96673, 0x166A08 };
BYTE patch_compare[NUM_KNOWN_PATCHES][PATCH_COMPARE_SIZE] =
{
	//{0x8b, 0x89, 0x6c, 0x27, 0x00, 0x00, 0x39, 0xb9, 0x80, 0x4b, 0x00, 0x00},  //winvis - 6.0.6002.18005
	{ 0x8b, 0x89, 0xe8, 0x29, 0x00, 0x00, 0x39, 0xb9, 0x80, 0x4b, 0x00, 0x00 },  //win7   - 6.1.7601.16562
	{ 0x8b, 0x89, 0xe8, 0x29, 0x00, 0x00, 0x39, 0xb9, 0x80, 0x4b, 0x00, 0x00 },  //win7   - 6.1.7600.16385
	{ 0x8b, 0x89, 0xe8, 0x29, 0x00, 0x00, 0x39, 0xb9, 0x80, 0x4b, 0x00, 0x00 },  //win7   - 6.1.7601.17514
	{ 0x8b, 0x80, 0xe8, 0x29, 0x00, 0x00, 0x39, 0xb0, 0x40, 0x4c, 0x00, 0x00 },  //win8.1 - 6.3.9431.00000
	{ 0x80, 0xe8, 0x29, 0x00, 0x00, 0x83, 0xb8, 0x40, 0x4c, 0x00, 0x00, 0x00 },  //win8.1 - 6.3.9600.16404
	{ 0x81, 0xe8, 0x29, 0x00, 0x00, 0x83, 0xb8, 0xa0, 0x4c, 0x00, 0x00, 0x00 },  //win10  - 10.0.10240.16384
	{ 0x81, 0xe8, 0x29, 0x00, 0x00, 0x83, 0xb8, 0xa0, 0x4c, 0x00, 0x00, 0x00 },  //win10  - 10.0.10162.0
	{ 0x81, 0xe8, 0x29, 0x00, 0x00, 0x83, 0xb8, 0xa0, 0x4c, 0x00, 0x00, 0x00 },  //win10  - 10.0.10240.16412
	{ 0x80, 0xe8, 0x29, 0x00, 0x00, 0x83, 0xb8, 0x40, 0x4c, 0x00, 0x00, 0x00 },  //win8.1 - 6.3.9600.17095
	{ 0x80, 0xe8, 0x29, 0x00, 0x00, 0x83, 0xb8, 0x40, 0x4c, 0x00, 0x00, 0x00 },  //win8.1 - 6.3.9600.17085
	{ 0x80, 0xe8, 0x29, 0x00, 0x00, 0x83, 0xb8, 0x40, 0x4c, 0x00, 0x00, 0x00 },  //win8.1 - 6.3.9600.16384
	{ 0x87, 0xe8, 0x29, 0x00, 0x00, 0x83, 0xb8, 0x40, 0x4c, 0x00, 0x00, 0x00 },  //win8.1 - 6.3.9600.17415
	{ 0x81, 0x18, 0x2a, 0x00, 0x00, 0x83, 0xb8, 0xa0, 0x4c, 0x00, 0x00, 0x00 },  //win10  - 10.0.10586.0
	{ 0x81, 0x18, 0x2a, 0x00, 0x00, 0x83, 0xb8, 0xa0, 0x4c, 0x00, 0x00, 0x00 },  //win10  - 10.0.10586.494
	{ 0x81, 0x18, 0x2a, 0x00, 0x00, 0x83, 0xb8, 0xa8, 0x4c, 0x00, 0x00, 0x00 },  //win10  - 10.0.14393.0
	{ 0x8b, 0x80, 0xe8, 0x29, 0x00, 0x00, 0x39, 0x90, 0xb0, 0x4b, 0x00, 0x00 },  //win8   - 6.2.9200.16384
};

static const BYTE forceJump[] = { 0xEB };
static const BYTE ignoreJump[] = { 0x90, 0x90 };

PatchInfo patch[NUM_KNOWN_PATCHES] =
{
	//{0xEB, 0x02},
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(forceJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(ignoreJump),
	NewPatch(forceJump),
};

#endif

int GetD3D9PatchType()
{
	LPBYTE lpBaseAddress = (LPBYTE)hD3D9Dll;
	for (int i = 0; i < NUM_KNOWN_PATCHES; i++)
	{
		if (CompareMemory(lpBaseAddress + patch_offsets[i], patch_compare[i], PATCH_COMPARE_SIZE))
		{
			patchType = i + 1;
			return i + 1;
		}
			
	}

	return 0;
}

LPBYTE GetD3D9PatchAddress()
{
	if (patchType)
	{
		LPBYTE lpBaseAddress = (LPBYTE)hD3D9Dll;
		return lpBaseAddress + patch_offsets[patchType - 1] + PATCH_COMPARE_SIZE;
	}

	return NULL;
}

//-----------------------------------------------------------------
// new workaround for GPU copy stuff

static bool offsetWorkaround = false;
static UINT32 offset_D3D9 = 0;
static UINT32 offset_isD3D9Ex = 0;

#ifdef _WIN64
#define CMP_SIZE 21
static const BYTE mask[CMP_SIZE] = { 0xF8, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00 };
static const BYTE mask_cmp[CMP_SIZE] = { 0x48, 0x8B, 0x80, 0x00, 0x00, 0x00, 0x00, 0x39, 0x80, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x40, 0xB8, 0x00, 0x00, 0x00, 0x00 };
#else

#define CMP_SIZE 19
static const BYTE mask[CMP_SIZE] = { 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00 };
static const BYTE mask_cmp[CMP_SIZE] = { 0x8B, 0x80, 0x00, 0x00, 0x00, 0x00, 0x39, 0x80, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00 };
#endif

#define MAX_FUNC_SCAN_BYTES 200

static inline bool PatternMatches(BYTE *byte)
{
	for (size_t i = 0; i < CMP_SIZE; i++) {
		if ((byte[i] & mask[i]) != mask_cmp[i])
			return false;
	}

	return true;
}

void FindD3D9ExOffsets(IDirect3D9Ex *d3d9ex, IDirect3DDevice9Ex *dev)
{
	BYTE **vt = *(BYTE***)dev;
	BYTE *crr = vt[125];

	for (size_t i = 0; i < MAX_FUNC_SCAN_BYTES; i++) {
		if (PatternMatches(&crr[i])) {
#define GetOffset(x) *(UINT32*)(&crr[i + x])
#ifdef _WIN64
			UINT32 off1 = GetOffset(3);
			UINT32 off2 = GetOffset(9);
#else
			UINT32 off1 = GetOffset(2);
			UINT32 off2 = GetOffset(8);
#endif

			if (off1 > 0xFFFF || off2 > 0xFFFF)
				break;

			__try {
				BYTE *ptr = (BYTE*)(dev);
				BYTE *d3d9_ptr = *(BYTE**)(ptr + off1);

				BOOL &is_d3d9ex = *(BOOL*)(d3d9_ptr + off2);
				if (is_d3d9ex != TRUE)
					continue;

			}
			__except (EXCEPTION_EXECUTE_HANDLER) {
				break;
			}

			offset_D3D9 = off1;
			offset_isD3D9Ex = off2;
			offsetWorkaround = true;
			break;
		}
	}
}

 

BOOL D3D9Patch::m_bIsPatched = FALSE;

D3D9Patch::D3D9Patch()
	: m_pSavePatch(NULL)
	, m_dwOldProtect(0)
{

}

D3D9Patch::~D3D9Patch()
{
	
}

BOOL D3D9Patch::Patch(IDirect3DDevice9 *device, PatchCallback* _callback)
{
	//------------------------------------------------
	//修改资源
	LPBYTE patchAddress = (patchType != 0) ? GetD3D9PatchAddress() : NULL;
	DWORD dwOldProtect;
	size_t patch_size;
	BOOL *pIsD3D9Ex = nullptr;
	BOOL wasD3D9Ex = false;

	if (patchAddress)
	{
		std::cout << "DoD3D9GPUHook: offset workaround appears unavailable" << std::endl;

		patch_size = patch[patchType - 1].patchSize;
		m_pSavePatch = (BYTE*)malloc(patch_size);
		if (VirtualProtect(patchAddress, patch_size, PAGE_EXECUTE_READWRITE, &dwOldProtect))
		{
			memcpy(m_pSavePatch, patchAddress, patch_size);
			memcpy(patchAddress, patch[patchType - 1].patchData, patch_size);
		}
		else
		{
			std::cout<< "DoD3D9GPUHook: unable to change memory protection, result = " << GetLastError() << std::endl;
			goto finishHook;
		}
		 
	}
	else if (offsetWorkaround)
	{
		std::cout<<  "DoD3D9GPUHook: using offset workaround" << std::endl;

		BYTE *devicePtr = (BYTE*)device;
		BYTE *d3d9Ptr = *(BYTE**)(devicePtr + offset_D3D9);
		pIsD3D9Ex = (BOOL*)(d3d9Ptr + offset_isD3D9Ex);

		wasD3D9Ex = *pIsD3D9Ex;
		*pIsD3D9Ex = true; 
		 
	}


	_callback->CallbackPatch(device);
	 

	//恢复资源
	if (patchAddress)
	{
		memcpy(patchAddress, m_pSavePatch, patch_size);
		VirtualProtect(patchAddress, patch_size, dwOldProtect, &dwOldProtect);
	}
	else if (offsetWorkaround)
	{
		*pIsD3D9Ex = wasD3D9Ex;
	}
///创建纹理
	/*if (FAILED(hErr = d3d9Tex->GetSurfaceLevel(0, &copyD3D9TextureGame)))
	{
		RUNEVERYRESET logOutput << CurrentTimeString() << "DoD3D9GPUHook: d3d9Tex->GetSurfaceLevel failed, result = " << (UINT)hErr << endl;
		d3d9Tex->Release();
		goto finishGPUHook;
	}*/


finishHook:
	free(m_pSavePatch);
	m_pSavePatch = NULL;
	return FALSE;
}
 
 